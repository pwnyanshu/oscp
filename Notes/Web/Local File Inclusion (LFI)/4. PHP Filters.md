## 1. Why PHP Filters Matter

In PHP-based web apps, **Local File Inclusion (LFI)** often executes `.php` files instead of showing their source.  
That’s a problem because:

- Executed PHP files **don’t reveal credentials**
- Config files often **produce no output**
- You lose visibility into application logic

**PHP filters solve this by transforming file contents before execution**, allowing **source code disclosure**.

---

## 2. PHP Wrappers vs PHP Filters

### PHP Wrappers

Wrappers allow access to different I/O streams.

Examples:

- `php://input`
- `php://filter`
- `data://`
- `expect://`

Wrappers are powerful and can lead to **RCE**, not just file read.

### PHP Filters

A **special wrapper** that processes input/output using filters.

Used mainly for:

- Reading PHP source code
- Encoding content (base64)
- Bypassing execution

---

## 3. PHP Filter Syntax

`php://filter/read=<FILTER>/resource=<FILE>`

Important parts:

- `php://filter` → filter wrapper
- `read=` → apply filter when reading
- `resource=` → target file

---

## 4. Key Filter Types (Only One You Actually Need)

PHP provides multiple filter types:

- String Filters
- Conversion Filters
- Compression Filters
- Encryption Filters

**Only useful one for LFI:**

`convert.base64-encode`

Why?

- Prevents PHP execution
- Returns encoded source code

---

## 5. Standard LFI Problem (Why Filters Are Needed)

Example vulnerable endpoint:

`/index.php?language=config`

If app appends `.php`, actual file:

`config.php`

Result:

- PHP executes
- No output
- Source code hidden

---

## 6. Base64 Filter Exploitation (Core Technique)

### Payload

`php://filter/read=convert.base64-encode/resource=config`

### Full URL Example

`http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=config`

What happens:

- `config.php` is read
- PHP code is **encoded**
- Execution is bypassed
- Source becomes visible

![[Pasted image 20251219114759.png]]

![[Pasted image 20251219114812.png]]

---

## 7. Decoding the Output

The response will be Base64 text.

Decode it:

`echo '<BASE64_STRING>' | base64 -d`

Now you can see:

- Database credentials
- API keys
- Hardcoded secrets
- File paths
- Further includes

---

## 8. Why Resource Is at the End

Most vulnerable apps **append `.php` automatically**.

So:

`resource=config`

Becomes:

`config.php`

If you add `.php` yourself, it may break.

---

## 9. Fuzzing for PHP Files (Before Using Filters)

Find files first.

Example with `ffuf`:

`ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ \ -u http://<SERVER_IP>:<PORT>/FUZZ.php`

Important:

- Include **302, 403, 301**
- LFI ignores HTTP access restrictions
![[Pasted image 20251219114732.png]]

---

## 10. Practical Workflow (Realistic Attack Flow)

1. Detect LFI
2. Fuzz for `.php` files
3. Identify config / include files
4. Use base64 filter
5. Decode source
6. Extract secrets
7. Pivot to:
    - RCE
    - Database access
    - Further file inclusion

---

## 11. Key Takeaways (Non-Negotiable)

- Normal LFI executes PHP → useless for secrets
- `php://filter` converts execution into disclosure
- `convert.base64-encode` is the weapon
- Always decode offline
- Filters ≠ wrappers (filters are safer, wrappers are dangerous)

---

## 12. One-Line Cheat Payload

`/index.php?language=php://filter/read=convert.base64-encode/resource=config`

---

These notes are **exam-ready**, **OSCP-relevant**, and **HTB-accurate**.  
If you want, the next logical step is **PHP wrappers → RCE**, which is where most people screw up because they mix execution contexts without understanding why it works.